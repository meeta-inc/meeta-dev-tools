<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Streaming Chat Test - AI Navi Backend Mock</title>
  <style>
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; 
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }
    
    .container {
      display: flex;
      gap: 20px;
    }
    
    .panel {
      flex: 1;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 20px;
    }
    
    h1 { color: #333; }
    h2 { color: #666; font-size: 18px; }
    
    .controls {
      margin-bottom: 20px;
      padding: 15px;
      background: #f5f5f5;
      border-radius: 8px;
    }
    
    .control-group {
      margin-bottom: 10px;
    }
    
    label {
      display: inline-block;
      width: 100px;
      font-weight: bold;
    }
    
    input, select {
      padding: 5px 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    
    input[type="text"] {
      width: 300px;
    }
    
    button {
      background: #007AFF;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }
    
    button:hover {
      background: #0051D5;
    }
    
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    #latency {
      margin-top: 10px;
      padding: 10px;
      background: #fff3cd;
      border: 1px solid #ffc107;
      border-radius: 4px;
      color: #856404;
      font-size: 14px;
    }
    
    #output {
      white-space: pre-wrap;
      background: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #dee2e6;
      min-height: 200px;
      max-height: 400px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.5;
    }
    
    .bubble-container {
      margin-top: 20px;
    }
    
    .bubble {
      background: #007AFF;
      color: white;
      border-radius: 18px;
      padding: 12px 18px;
      margin: 10px 0;
      display: inline-block;
      max-width: 80%;
      animation: slideIn 0.3s ease-out;
      font-size: 14px;
      line-height: 1.4;
    }
    
    .bubble.main {
      background: #007AFF;
    }
    
    .bubble.sub {
      background: #5AC8FA;
    }
    
    .bubble.cta {
      background: #FF9500;
    }
    
    .bubble-type {
      font-size: 10px;
      text-transform: uppercase;
      opacity: 0.8;
      margin-bottom: 4px;
    }
    
    .bubble-text {
      font-size: 14px;
    }
    
    .bubble-attachment {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255,255,255,0.3);
      font-size: 12px;
    }
    
    .bubble-attachment a {
      color: white;
      text-decoration: underline;
    }
    
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .status {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
      margin-left: 10px;
    }
    
    .status.connecting { background: #ffc107; color: #856404; }
    .status.connected { background: #28a745; color: white; }
    .status.error { background: #dc3545; color: white; }
    .status.done { background: #6c757d; color: white; }
  </style>
</head>
<body>
  <h1>AI Navi Backend Mock - Streaming Chat Test</h1>
  
  <div class="controls">
    <div class="control-group">
      <label>Grade ID:</label>
      <select id="gradeSelect">
        <option value="preschool">Preschool</option>
        <option value="elementary">Elementary (서브 버블 포함)</option>
        <option value="middle">Middle</option>
        <option value="high">High</option>
      </select>
    </div>
    
    <div class="control-group">
      <label>Message:</label>
      <input type="text" id="messageInput" value="北海道大学を受験したいです" />
    </div>
    
    <div class="control-group">
      <label>Mock Server:</label>
      <input type="text" id="serverUrl" value="http://localhost:3001" />
    </div>
    
    <button id="sendBtn" onclick="sendStreamingRequest()">Send Streaming Request</button>
    <span id="status" class="status"></span>
  </div>
  
  <div id="latency"></div>
  
  <div class="container">
    <div class="panel">
      <h2>Raw Stream Output</h2>
      <div id="output"></div>
    </div>
    
    <div class="panel">
      <h2>Parsed Bubbles</h2>
      <div id="bubbles" class="bubble-container"></div>
    </div>
  </div>

  <script>
    let eventSource = null;
    
    function updateStatus(status, text) {
      const statusEl = document.getElementById('status');
      statusEl.className = `status ${status}`;
      statusEl.textContent = text;
    }
    
    async function sendStreamingRequest() {
      console.log('sendStreamingRequest called');
      const output = document.getElementById('output');
      const latency = document.getElementById('latency');
      const bubbles = document.getElementById('bubbles');
      const sendBtn = document.getElementById('sendBtn');
      
      console.log('Elements found:', { output, latency, bubbles, sendBtn });
      
      // 초기화
      output.textContent = '';
      latency.textContent = '';
      bubbles.innerHTML = '';
      
      // 기존 연결 종료
      if (eventSource) {
        eventSource.close();
      }
      
      const gradeId = document.getElementById('gradeSelect').value;
      const message = document.getElementById('messageInput').value;
      const serverUrl = document.getElementById('serverUrl').value;
      
      sendBtn.disabled = true;
      updateStatus('connecting', 'Connecting...');
      
      const start = performance.now();
      let firstChunk = true;
      
      try {
        // JWE 토큰 생성 (간단한 mock 토큰)
        const jweToken = 'eyJhbGciOiJBMjU2S1ciLCJlbmMiOiJBMjU2R0NNIn0.mock-token-for-testing';
        
        console.log('Making fetch request to:', `${serverUrl}/students/chat/stream`);
        const response = await fetch(`${serverUrl}/students/chat/stream`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-JWE-Token': jweToken
          },
          body: JSON.stringify({
            clientId: 'RS000001',
            appId: '0001',
            gradeId: gradeId,
            userId: 'TEST_USER',
            message: message
          })
        });
        
        console.log('Response received:', response.status, response.statusText);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        console.log('Response is OK, setting up stream reader');
        updateStatus('connected', 'Connected');
        
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        
        console.log('Starting stream read loop');
        while (true) {
          console.log('Reading next chunk...');
          const { done, value } = await reader.read();
          console.log('Read result:', { done, valueLength: value ? value.length : 0 });
          
          if (firstChunk && value) {
            const elapsed = Math.round(performance.now() - start);
            latency.textContent = `첫 청크까지 대기 시간: ${elapsed}ms`;
            firstChunk = false;
          }
          
          if (done) {
            console.log('Stream is done, breaking loop');
            break;
          }
          
          const chunk = decoder.decode(value, { stream: true });
          console.log('Received chunk:', chunk);
          buffer += chunk;
          
          // SSE 파싱
          const lines = buffer.split('\n');
          buffer = lines.pop() || ''; // 마지막 불완전한 라인은 버퍼에 보관
          
          for (const line of lines) {
            console.log('Processing line:', line);
            if (line.startsWith('data: ')) {
              const data = line.slice(6);
              console.log('SSE data:', data);
              output.textContent += `[${new Date().toISOString()}] ${data}\n`;
              
              try {
                const parsed = JSON.parse(data);
                console.log('Parsed data:', parsed);
                
                if (parsed.type === 'bubble') {
                  const bubble = parsed.data;
                  const bubbleEl = document.createElement('div');
                  bubbleEl.className = `bubble ${bubble.type}`;
                  
                  let html = `
                    <div class="bubble-type">${bubble.type.toUpperCase()} BUBBLE</div>
                    <div class="bubble-text">${bubble.text}</div>
                  `;
                  
                  if (bubble.attachment) {
                    html += `
                      <div class="bubble-attachment">
                        <strong>${bubble.attachment.title || 'Attachment'}</strong><br>
                        <a href="${bubble.attachment.url}" target="_blank">${bubble.attachment.url}</a>
                        ${bubble.attachment.description ? `<br>${bubble.attachment.description}` : ''}
                      </div>
                    `;
                  }
                  
                  bubbleEl.innerHTML = html;
                  bubbles.appendChild(bubbleEl);
                } else if (parsed.type === 'done') {
                  updateStatus('done', 'Stream completed');
                  const totalElapsed = Math.round(performance.now() - start);
                  latency.textContent += ` | 전체 수신 시간: ${totalElapsed}ms`;
                }
              } catch (e) {
                console.error('Failed to parse SSE data:', e);
              }
            } else if (line.startsWith(':')) {
              // 주석 또는 ping
              output.textContent += `[PING] ${line}\n`;
            }
          }
        }
        
      } catch (error) {
        console.error('Streaming error:', error);
        console.error('Error details:', {
          name: error.name,
          message: error.message,
          stack: error.stack
        });
        updateStatus('error', `Error: ${error.message}`);
        output.textContent += `\n[ERROR] ${error.message}`;
      } finally {
        sendBtn.disabled = false;
      }
    }
    
    // Enter 키로 전송
    document.getElementById('messageInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !document.getElementById('sendBtn').disabled) {
        sendStreamingRequest();
      }
    });
  </script>
</body>
</html>